# ЛАБОРАТОРНАЯ РАБОТА №4 BIOPYTHON
# Вариант 21. Биологические виды: Thylacinus cynocephalus и Homo Sapiens (∪.∪ )...zzz

# Задание 1. Формирование исходного файла
по образцу экспортировал файлы из базы данных genbank

получил два файла с названиями sequence (2).gb и sequence (3).gb

Приступим писать код:


Импортировал библиотеку SeqIO - модуль Biopython для чтения/записи биологических последовательностей в разных форматах (GenBank, FASTA и др.).

Далее в переменные загнал пути к файлам, которые экспортировал с NCBI. Сделал это для удобства работы.

Также в переменную загнал имя итогового файла, в который будут записаны все записи из первых двух файлов.
# Ошибка:
Пенрвоначально использовал raw-строку, однако там возникла ошибка, хотя код и сработал.
## Как устранил? 
ИСПОЛЬЗОВАЛ ПРЯМЫЕ СЛЕШИ, ТАК КАК ПРИ ИСПОЛЬЗОВАНИИ RAW-СТРОКИ ПИТОН СЧИТЫВАЛ \f как спец. команду.

Далее с помощью функции with ... as и цикла for осуществил открывание файла для записи ("w" - write).
Всё, что будет записано внутри этого блока, попадёт в файл combined_species.gb.

методы:

SeqIO.parse() -- читает записи из файла по одной. 
SeqIO.write(record, outfile, "genbank") - записывает каждую запись в итоговый файл.

Через print вывел на экран то, что файлы были объединены.


# Задание 2. GC-составы
Входным файлом является файл GenBank, составленный в задании 1.
Нужно прочитать все записи и вывести последовательности в порядке возрастания их GC-составов.

поскольку новый пайтон файл, опять импортировал библиотеку SeqIO

написал функцию, которая на вход берёт строку с ДНК-последовательностью (sequence), далее считает сколько 'G' (гуанина) и 'C' (цитозина) в последовательности с помощью метода count, а также находит их процент: (число G + число C) / общую длину * 100. В итоге возвращает процент GC-состава. Если последовательность пустая (длина равна 0), функция возвращает 0.
Переменной total_count присвоил значение len(sequence), это для того, чтобы символы гуанина и цитозина считались по всей длине последовательности.

Приступил к следующему шагу:
Создал функцию main, которая принимает путь к файлу input_file как аргумент.
Далее создал пустой список с именем records_gc, чтобы в дальнейшем в этот список могли добавляться данные(в моём случае, кортежи вида record, gc_content),
record - это объект последовательности из файла GenBank,
а gc_content - рассчитанный для этой последовательности процент содержания GC.


Всё это сделал потому, что после заполнения списка его можно удобно отсортировать по GC-составу и перебрать для вывода или других операций.

Далее применил уже известный цикл for, который через объект record(запись) будет работать в  SeqIO.parse(input_file, "genbank") — это метод для чтения файла формата GenBank, который возвращает итератор по записям (генетическим данным).
Итак:

С помощью метода str функция реобразует последовательность в строку (str(record.seq)).

С помощью функции calculate_gc_content рассчитывает содержание GC.

Добавляет кортежи (record, gc_content) в список records_gc.

---------------------------------------------------------------------------------------------------------------------
Далее прописал строку: records_gc.sort(key=lambda x: x[1])

Она сортирует список records_gc по второму элементу каждого кортежа.


Воспользовался методом sort(). Он сортирует элементы "на месте" (то есть, зменяется сам список).

---------------------------------------------------------------------------------------------------------------------
Далее воспользовался лямбда-функцией, что сказать программе, по какому критерию сортировать. В моём случае, для каждого элемента x возвращает его второй элемент (x).

---------------------------------------------------------------------------------------------------------------------
Далее прописал ещё один цикл, который перебирает все элементы в списке records_gc и выводит информацию о каждой последовательности.

ID: {record.id} --  идентификатор последовательности.

GC Content: {gc_content:.2f}% -- процент содержания GC, округлённый до двух знаков после запятой.

Sequence: {record.seq} -- сама последовательность ДНК/РНК.

---------------------------------------------------------------------------------------------------------------------
Последним этапом я вывел на экран всё это мракобесие, указав через функции для пайтона буквально такую фразу: ''Если файл запускается как основная программа, вызывается функция main с указанным файлом.''

Вот результат:

<img width="560" alt="image" src="https://github.com/user-attachments/assets/a356ab6b-e271-4141-bbe0-529a2ace1646" />


# Задание 3. Трансляция

с помощью цикла for моя программа пробегает с помощью объекта record по записям из файла genbank
Далее новый цикл для каждой записи перебирает все аннотированные фичи (features).
Если фича - это CDS (кодирующая последовательность), то получает ID записи (record.id), описание записи (record.description), расположение CDS (feature.location), трансляцию (белковую последовательность, если есть) из аннотаций (feature.qualifiers['translation']).

После этого выодит на экран ID и описание последовательности, координаты CDS (старт, стоп, цепь), трансляцию белковой последовательности.

Также, я для удобства восприятия поставил между строками разделение с помощью метода  print().

Абсолютно по такой же технологии, как и в задании 2 последним этапом я вывел на экран всё это мракобесие, указав через функции для python буквально такую фразу: ''Если файл запускается как основная программа, вызывается функция main с указанным файлом.''

Результат работы:

<img width="872" alt="image" src="https://github.com/user-attachments/assets/05683833-31f5-4a24-94d1-0b92ba88a917" />

-----------------------------------------------------------------------------------------------------------------------

# Спасибо за внимание и уделённое время!
# (〃￣︶￣)人(￣︶￣〃)
