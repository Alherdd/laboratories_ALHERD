# ЛАБОРАТОРНАЯ РАБОТА №4 BIOPYTHON
# Вариант 21. Биологические виды: Thylacinus cynocephalus и Homo Sapiens (∪.∪ )...zzz


# Цель:
Исследовать biopython.

# Задача:
Сформировать исходный файл:
-
1.Реализовать метод инициализации данных.

2.Протестировать реализованный код.

3.Проверить быстродействие кода.

4.Реализовать вывод данных в консоль.

Вывести последовательности в порядке возрастания их GC-составов:
-
1.Реализовать метод инициализации данных и алгоритм написания программы

2.Протестировать реализованный алгоритм и выходные данные.

3.Проверить быстродействие кода.

4.Реализовать вывод данных в консоль.

Вывести все белковые последовательности, которые получаются в результате трансляции кодирующих областей в заданных последовательностях:
-
1.Реализовать метод инициализации данных

2.Разработать алгоритм для выполненеия программы

3.Протестировать реализованный алгоритм и выходные данные.

4.Проверить быстродействие кода (ЦИКЛОМАТИЧЕСКАЯ СЛОЖНОСТЬ, ВЫЧИСЛИТЕЛЬНАЯ СЛОЖНОСТЬ, потребляемая память).

5.Реализовать вывод данных в консоль.

# Задание 1. Формирование исходного файла

1.Реализация метода инициализации данных
-
Для инициализации данных был реализован список входных файлов input_files, содержащий пути к объединяемым файлам в формате GenBank. Это позволяет легко масштабировать решение - для объединения большего количества файлов достаточно добавить их пути в список. Также был определён путь к выходному файлу output_file, в который будут записаны все последовательности.

       input_files = [
           "D:/first/pythonProject/sequence (2).gb",
           "D:/first/pythonProject/sequence (3).gb"
       ]
       output_file = "combined_species.gb"

2.Тестирование реализованного кода
-
Код был протестирован на двух GenBank-файлах. После выполнения программы был проверен выходной файл combined_species.gb:

В файле присутствуют все записи из обоих исходных файлов.

Формат выходного файла соответствует формату GenBank.

Ошибок при выполнении не возникло.


3.Проверка быстродействия кода
-

*Цикломатическая сложность равна 1 - код линейный без ветвлений. (Нет ветвлений, только последовательные циклы)*

*Вычислительная сложность - линейная O(n) по общему числу записей.*

*Потребляема память - O(1) по количеству записей, то есть константный объём памяти, не зависящий от размера данных. (Обработка записи за записью, без накопления данных)*

4.Реализация вывода данных в консоль
-
Для информирования пользователя о ходе выполнения программы реализовал вывод сообщения о завершении объединения файлов через print.


# Задание 2. GC-составы

1.Метод инициализации данных и алгоритм.
-
Входным файлом является файл GenBank, составленный в задании 1.
Нужно прочитать все записи и вывести последовательности в порядке возрастания их GC-составов.

написал функцию, которая на вход берёт строку с ДНК-последовательностью (sequence), далее считает сколько 'G' (гуанина) и 'C' (цитозина) в последовательности с помощью метода count, а также находит их процент: (число G + число C) / общую длину * 100. В итоге возвращает процент GC-состава. Если последовательность пустая (длина равна 0), функция возвращает 0.
Переменной total_count присвоил значение len(sequence), это для того, чтобы символы гуанина и цитозина считались по всей длине последовательности.

Приступил к следующему шагу:
Создал функцию main, которая принимает путь к файлу input_file как аргумент.
Далее создал пустой список с именем records_gc, чтобы в дальнейшем в этот список могли добавляться данные(в моём случае, кортежи вида record, gc_content),
record - это объект последовательности из файла GenBank,
а gc_content - рассчитанный для этой последовательности процент содержания GC.

Далее применил цикл for, который через объект record(запись) будет работать в  SeqIO.parse(input_file, "genbank") — это метод для чтения файла формата GenBank, который возвращает итератор по записям (генетическим данным).
Итак:

С помощью метода str функция реобразует последовательность в строку (str(record.seq)).

С помощью функции calculate_gc_content рассчитывает содержание GC.

Добавляет кортежи (record, gc_content) в список records_gc.

Далее прописал ещё один цикл, который перебирает все элементы в списке records_gc и выводит информацию о каждой последовательности.

ID: {record.id} --  идентификатор последовательности.

GC Content: {gc_content:.2f}% -- процент содержания GC, округлённый до двух знаков после запятой.

Sequence: {record.seq} -- сама последовательность ДНК/РНК.

2.Тестирование реализованного алгоритма и выходных данных.
-
Код был протестирован на файле combined_species.gb, содержащем несколько последовательностей в формате GenBank.

Для каждой последовательности корректно вычислялось GC-содержание.

Записи успешно сортировались по значению GC-содержания в порядке возрастания.

В консоль выводились идентификатор записи, GC-содержание с точностью до двух знаков после запятой и сама последовательность.

Проверка на пустую последовательность (длина равна 0) корректно обрабатывалась функцией calculate_gc_content, возвращая 0%.

3.Быстродействие кода
-
*Общая вычислительная сложность приблизительно O(n * m + n log n).*

*Цикломатическая сложность близка к O(1) для calculate_gc_content и O(n) для main, где n - число записей в файле.*

*Память используется для хранения всех записей и их GC содержаний в списке records_gc.
Память пропорциональна количеству записей и длине последовательностей, то есть O(n * m).
При использовании Biopython SeqIO.parse объекты SeqRecord создаются для каждой записи, что добавляет накладные расходы по памяти и времени из-за создания объектов.*

n - число записей в файле.
m - длина последовательности.

4.Вывод данных в консоль.
-
Для информирования пользователя о ходе выполнения программы реализован вывод сообщения о завершении объединения файлов.

*Кратко что написал словами: ''Если файл запускается как основная программа, вызывается функция main с указанным файлом.''*

Вот результат:

<img width="560" alt="image" src="https://github.com/user-attachments/assets/a356ab6b-e271-4141-bbe0-529a2ace1646" />


# Задание 3. Трансляция

1.Метод инициализации данных
-

2.Разработать алгоритм для выполненеия программы
-

3.Протестировать реализованный алгоритм и выходные данные.
-

4.Проверить быстродействие кода (ЦИКЛОМАТИЧЕСКАЯ СЛОЖНОСТЬ, ВЫЧИСЛИТЕЛЬНАЯ СЛОЖНОСТЬ, потребляемая память).
-

5.Реализовать вывод данных в консоль.
-
1.Реализовать метод инициализации данных
-
с помощью цикла for моя программа пробегает с помощью объекта record по записям из файла genbank
Далее новый цикл для каждой записи перебирает все аннотированные фичи (features).
Если фича - это CDS (кодирующая последовательность), то получает ID записи (record.id), описание записи (record.description), расположение CDS (feature.location), трансляцию (белковую последовательность, если есть) из аннотаций (feature.qualifiers['translation']).

2.Разработать алгоритм для выполненеия программы

С помощью SeqIO.parse происходит чтение GenBank файла по записям.

Для каждой записи перебираются все её аннотации (features).

Если аннотация типа "CDS" (кодирующая последовательность), извлекаются:

ID записи (record.id)

Описание записи (record.description)

Локация кодирующей последовательности (feature.location)

Перевод белковой последовательности (feature.qualifiers['translation'])

Затем данные выводятся в консоль.

Алгоритм однопроходный, без лишних вложенных циклов.

5. Реализация вывода данных в консоль
Вывод реализован через print с форматированием строк.

Информация выводится в читаемом виде: ID, описание, локация, перевод.

Отсутствуют цветовые выделения или структурирование (например, разделители между записями).

Вывод происходит сразу при обработке каждой CDS, что удобно для потокового анализа.

Итог
Ваш код корректно реализует основную задачу - извлечение и вывод белковых последовательностей из GenBank файла. Он прост и понятен, использует стандартные средства Biopython.
3.Протестировать реализованный алгоритм и выходные данные.

4.Проверить быстродействие кода (ЦИКЛОМАТИЧЕСКАЯ СЛОЖНОСТЬ, ВЫЧИСЛИТЕЛЬНАЯ СЛОЖНОСТЬ, потребляемая память).
-
*Цикломатическая сложность: Основной цикл по записям и вложенный по feature - 2 уровня, Условие if feature.type == "CDS" - ветвление,*

*Итого: примерно 3-4 (зависит от детализации).*

*Вычислительная сложность: O(n * m), где n - количество записей в файле, m - количество features на запись.*

*Алгоритм линейный по размеру входных данных.*

*Потребляемая память: Память зависит от размера текущей записи и количества CDS в ней.*

5.Реализовать вывод данных в консоль.
-
Вывод на экран ID и описание последовательности, координаты CDS (старт, стоп, цепь), трансляцию белковой последовательности.

Также, я для удобства восприятия поставил между строками разделение с помощью метода  print().

Абсолютно по такой же технологии, как и в задании 2 последним этапом вывел на экран, указав через функции для python фразу: ''Если файл запускается как основная программа, вызывается функция main с указанным файлом.''

Результат работы:

<img width="872" alt="image" src="https://github.com/user-attachments/assets/05683833-31f5-4a24-94d1-0b92ba88a917" />

-----------------------------------------------------------------------------------------------------------------------

# Спасибо за внимание и уделённое время!
# (〃￣︶￣)人(￣︶￣〃)
